# Scene Types

In order to load/unload scene with uFrame, a scene must contain a single root game object that is a parent to all other game objects in the scene.

This root game object needs to have a _Scene Type_ component attached in order to be recognized by uFrame as a root game object.

![](https://dl.dropboxusercontent.com/u/75445779/uFrame_wiki/Screenshot_101.png)

_Scene Type_ node defines how to load a scene and allows for unloading the scene. You can create a _Scene Type_ node in the _MVVMGraph_ in the designer.

![](https://dl.dropboxusercontent.com/u/75445779/uFrame_wiki/Screenshot_102.png)

## Scene Type

uFrame will generate an empty class with the name of the scene type. You can add there custom fields and properties. Public fields will be displayed in the inspector.

If you have multiple scene using the same Scene Type you may want to add a custom field that can be adjusted for each scene separately, for eg. weather conditions on the scene. [Scene Loader](../scene-loaders.md) can later read the data while loading the scene to make the scene reflect the specified weather conditions.

[this code below should be a use case example documented with comments]

```csharp
public class MainMenuScene : MainMenuSceneBase {
    // WeatherCondition enum.
    public WeatherCondition WeatherCondition; // This will be displayed int the inspector.
    public int SomeIntProperty { get; set; } // This won't be displayed.
}
```

Below is an example of a scene base class that is automatically generated from the designer. It has a `DefaultKernelScene` property that defines the [kernel scene](../uframe-kernel.md) that will be loaden with the scene and a `Settings` property that will contain all settings passed to the scene from the `LoadSceneCommand`.

Example _UIScene.designer.cs_

```csharp
// ------------------------------------------------------------------------------
//  <autogenerated>
//      This code was generated by a tool.
//      Mono Runtime Version: 2.0.50727.1433
//
//      Changes to this file may cause incorrect behavior and will be lost if
//      the code is regenerated.
//  </autogenerated>
// ------------------------------------------------------------------------------

using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;


public class UISceneBase : Scene {

    public override string DefaultKernelScene {
        get {
            return "KernelScene";
        }
    }

    public virtual UISceneSettings Settings {
        get {
            return _SettingsObject as UISceneSettings;
        }
        set {
            _SettingsObject = value;
        }
    }
}
```

## Scene Type Settings

Scene Settings class is created along with the Scene Type. You can use it to pass data to the loaded scene.

Read more on the [Scene Settings](../scene-settings.md) page.

## Scene Loader

A scene loader is generated for every scene type that exists in the graph.

Scene loaders live as game objects on the [uFrame Kernel](../uframe-kernel.md).

![](https://dl.dropboxusercontent.com/u/75445779/uFrame_wiki/Screenshot_103.png)

When a scene with the corresponding _Scene Type_ is loaded, the scene loader will get a reference to the _Scene Type_ instance and pass it to the `LoadScene()` method. There you can use those settings to setup the scene properly. That gives a very fine grained control on how scenes are loaded and unloaded.

Below is an example of a loader class generated automatically for the _UISceneType_. It has two methods:

* `LoadScene()` that will be called after the scene is loaded additively by the Unity's `LoadSceneAdditively()` method. The process of loading the scene with the Unity's method is called _Instantiation_.
* `UnloadScene()` that is called right before the scene is unloaded (the scene root game object is destroyed).

Example _UIScene.designer.cs_

```csharp
// ------------------------------------------------------------------------------
//  <autogenerated>
//      This code was generated by a tool.
//      Mono Runtime Version: 2.0.50727.1433
//
//      Changes to this file may cause incorrect behavior and will be lost if
//      the code is regenerated.
//  </autogenerated>
// ------------------------------------------------------------------------------

using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;

public class UISceneLoaderBase : SceneLoader<UIScene> {

    protected override IEnumerator LoadScene(UIScene scene, Action<float, string> progressDelegate) {
        yield break;
    }

    protected override IEnumerator UnloadScene(UIScene scene, Action<float, string> progressDelegate) {
        yield break;
    }
}
```

Example of using the defined settings in the `LoadScene` method.

```csharp
// This ViewModel must be added to the subsystem instances in the designer.
// See Subsystems wiki page for details.
[inject] public MenuScreenViewModel MenuScreen;

protected override IEnumerator LoadScene(UIScene scene, Action<float, string> progressDelegate) {
    MenuScreen.Width = scene.Settings.Width;
    MenuScreen.Height = scene.Settings.Height;
}
```

## Designer

After creating new Scene Type in the designer, remember to _Save & Compile_ and then press the _Scaffold/Update Kernel_ button to update the Kernel prefab with the new [Scene Loader](../scene-loaders.md).

## Execution Order

When you enter play mode, first executed will be the `Start()` method which is responsible for loading the kernel. You can override the `KernelLoading()` method to execute custom code before the kernel starts loading and the `KernelLoaded()` to execute custom code after the kernel finish loading.

After the kernel is loaded, a `SceneAwakeEvent` is published. Read more in the [Events](../events.md) page.

[SceneManagementService](../classes/scenemanagementservice.md) will receive this event, find a Scene Loader for the Scene Type and call its `Load()` coroutine.
