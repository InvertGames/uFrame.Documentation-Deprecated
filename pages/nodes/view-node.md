# Views

Views are perhaps the easiest layer to understand in the context of Unity, due to the fact that they exist specifically to interact with the UnityEngine namespace and environment. Views are the _presentation_ layer, where the data of ViewModels is represented through the implementation of bindings. The idea is that for the most part, ViewModel data exists somewhere already, and Views merely "bind" to that data in order to represent changes in a way that Unity and players can understand.

Views generated by uFrame inherit from Monobehaviour, and therefore are much like normal Unity components. Building on top of Monobehaviour, uFrame ties into Unity methods like Update, Start, OnEnable, and OnDestroy in order to implement necessary MVVM functionality within the Unity environment. Every View that uFrame generates is meant to exist as a component on a particular GameObject. For instance, a PlayerView should probably exist on some kind of Player GameObject, and a PlayerHUDView should probably exist on some kind of GUI GameObject to bind to and express a player's stats and other properties.

[todo add picture of a View node]
[todo add picture of a View component]

Views are the so-called presentation layer, where a programmer will implement the logic of how the abstracted ViewModel data is represented in a particular environment. So if you have a _PlayerViewModel_, you may decide to represent that in any number of ways, including:

* a PlayerView that represents the player as an animated character moving in space
* a PlayerHUDView that represents the player's health, stamina, energy and other stats in your GUI
* and maybe a PlayerMapView that represents your player's position relative to some kind of GUI Map object

All of these would typically want to bind to the same player ViewModel instance, such that they are said to share the same ViewModel, representing the data in different ways. The most important distinction is that each of these views should concern themselves with ONLY their own representation, meaning that the PlayerView in the above example should not be updating GUI elements, but rather leave that to the PlayerHUDView or possibly PlayerMapView. Views should be as independent as possible, handling just themselves and their own interactions. Since any number of Views can bind to the same ViewModel instance, it is up to you to determine how many Views are needed and what their individual responsibilities will be in representing that data inside Unity.

## Important Methods

All Views inherit from a [ViewBase](../classes/viewbase.md) class. Here are the most important methods. You can override all of them.

`PreBind()`

This happens before the View begins creating bindings to its given ViewModel.

`Bind()`

This is where the View actually creates property bindings, collection bindings, and command bindings to the given ViewModel. The base.Bind() call will automatically create the bindings specified in the uFrame diagram for this specific View type. If you have any further manual bindings you need to do, this can be a good place to implement them.

`AfterBind()`

This is called immediately after the View creates bindings to its ViewModel.

`CreateModel()` (Obsolete)

This is when SceneFirst Views request a proper ViewModel from the scene's Dependency Container. For the most part, this should be left alone.

`InitializeViewModel()`

On a View, when the Initialize ViewModel option is checked in the inspector, this is where the base.InitializeViewModel() call will set the ViewModel's properties to the values of the View's matching properties (which are underscored in code on the View). This will usually never need to be overridden.

If you want to initialize ViewModel with the inspector data manually, use `View.InitializeData(ViewModel)` which is a public wrapper for `View.InitializeViewMode(VM)`.

`Awake()`, `Start()`, `OnEnable()`, `OnDisable()`, `OnDestroy()`, `Update()`, `LateUpdate()`

## Inspector options

*ViewModel Indentifier*

Name of the globally registered ViewModel instance. This instance will be used instead of creating a new one.

You can register VM globally by adding it to the Subsystem's node _Instances_ section.

*Inject This View*

If unchecked, the `[Inject]` attribute defined on the View class will not be active meaning that nothing will be injected into the View.

*Bind On Start*

If checked, the View will get associated with a specified globally registered VM or if none is specified, it'll create a new one. You could disable this option to be able to associate a View with a VM manually.

*Dispose On Destroy*

If checked and the View gets destroyed, the associated VM will be disposed. Check [ViewDestroyedEvent](../classes/viewdestroyedevent.md) for more info.

*Initialize ViewModel*

If checked, you'll see more options in the inspector. Those will allow you to specify default values for the properties of the associated ViewModel.

## Bindings

You can create bindings in the View node under _Bindings_ section. Each bindings will generate a method in the ViewBase class. Here are all methods that can be generated:

`{Name}Changed()`

[todo add content]

`{Name}StateChanged()`

Binding to a state property creates methods for each state, and in the designer code will property call the each state's method when it changes.

`{Name}CollectionChanged()`

Collection bindings bind to a collection giving you two methods, `{CollectionName}Added`, and `{CollectionName}Removed`, override these methods to execute something when the collection is modified.

`{Name}ViewCollectionChanged()`

The view collection changed binding automatically creates views for each element's viewmodel when created.

`{Name}Executed()`

The executed binding is for listening to when a command is invoked on a view. It will provide you with a method in the format `{CommandName}Executed({CommandClass} data)`.

`{Name}ToInputField()`

Binds a string property to an uGUI input field. A field will be created on the view for specifying the uGUI field.

`{Name}ToButton()`

The _ButtonToCommand_ binding will create a reference to a uGUI button on the view and automatically wire the click event to invoke the command.

`{Name}ToToggle()`

Bind toggle to property will bind a boolean property directly to a uGUI toggle box.

`{Name}ToText()`

Binds a string property to a uGUI text label.

`{Name}ToSlider()`

Binds a slider to a float value.

## Execution Order

There are actually several different entry points on generated Views. The usual order is:

**For Views instantiated at runtime**

Awake > OnEnable > PreBind > Bind > AfterBind > InitializeViewModel > Start > Update loop begins

**For Views existing "SceneFirst" before runtime**

Awake > OnEnable > CreateModel > InitializeViewModel > Start (before base call) > PreBind > Bind > AfterBind > Start (after base call)

**When Destroying an object**

OnDisable > OnDestroy (before base.OnDestroy() call) > UnBind > OnDestroy (after base.OnDestroy() call)

## When to call the base method

There are a few methods that ALWAYS need their _base.Method()_ calls intact, otherwise uFrame can easily produce unexpected results.

These methods include a majority of the overridden standard Unity methods:

- Awake(), Start(), OnEnable(), OnDisable(), OnDestroy(), Update(), LateUpdate()

- PreBind(), Bind(), AfterBind(), UnBind(), InitializeViewModel()

## Resoruces
[uFrame 1.5 - Views Youtube video](https://www.youtube.com/watch?v=P4BX0SI9wBk)
